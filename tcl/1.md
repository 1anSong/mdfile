## 每一条tcl指令都是“命令+参数" 的格式,第一个单词看作命令，其他的单词看作是命令的参数
```
puts "Hello,World"
输出结果:Hello,World
```

## TCL解释器运用规则把命令分成一个个独立的单词,同时进行必要的置换。
TCL置换分为以下三类
1.变量值换$

- TCL解释器会将认为$后面为变量名,将变量置换为它的值
```
set a "snow"
puts $a
输出结果: snow
```
2.命令置换[]

- []是一个独立的语句
```
set a [expr 3+4]
put $a
输出结果:7
```
3.反斜杠置换\

- 换行符,空格,[,$等被TCL解释器当作特殊字符对待的字符,加上反斜杠后变成普通字符.
```
set X = 1 
set Y = 1.5
puts "[expr $X+$Y]"
输出结果:2.5
puts "\[expr $X+$Y]"
输出结果:[expr 1+1.5]
puts "\[expr \$X+\$Y]"
输出结果:[expr $X+$Y]

```
- 用\t 表示 TAB 用\n 表示换行符
```
puts "a\tb"
输出结果:a	b
puts "a\nb"
输出结果:a
				 b
```
## 其他符号
1. "",TCL解释器对双引号**""**中$和[]符号会进行变量置换和命令置换
```
set a 1
set b 2
puts "$a"
puts "[expr $a+$b]"
输出结果:3
```
2. {}, 花括号中,所有的特殊字符都将成为普通字符，TCL解释器不会对其作特殊处理。
```
set a 1 
set b 2 
puts {\t[expr $a+$b]}
输出结果: \t[expr $a+$b]
```
3. # 表示注释


## 数组
数组:TCL中数组可以存储很多值,通过元素名来进行检索。类似于某件事物（数组名）几种不同的
属性（元素名），每一种属性有其独立的值。
定义:set 数组名(元素名) 值
```
set cell_1(ref_name) "bufx2"
set cell_1(full_name) "top/cell_1"
set cell_1(pins) "A B C"

```
取值:$数组名(元素名)
```
puts $cell_1(pins)
输出结果:A B C
```
使用array指令获取数组信息
```
array size cell_1
输出结果: 3
array names cell_1
ref_name  pins full_name 
```

## 列表
列表:列表是标量的有序集合。
定义: set 列表名{元素1 元素2 元素3 ...}
```
set ivt_list {ivtx2 ivtx3 ivtx8}
```
取值:$列表名
```
puts $ivt_list
输出结果: ivt2x2 ivtx3 ivtx8
```
### 列表元素
| 命令    | 功能                          |
|---------|-------------------------------|
| concat  | 合并两个列表                  |
| lindex  | 选取列表中的某个元素(从0开始) |
| llength | 列表长度                      |
| lappend | 在列表末端追加元素            |
| lsort   | 列表排序                      |

1. concat

```
set list1 {bufx1 bufx2 bufx4}
set list2 {ivtx1 ivtx2 ivtx4}
set a 1

set b [concat $list1 $list2] #这里会得到一个新列表,可以把这个列表赋值给一个变量
puts $b
输出结果: bufx1 bufx2  bufx4 ivtx1 ivtx2 ivtx4
```
- note: concat 不仅可以作用于列表,也可以作用于普通的变量
```
set a "hello"
set b "world"
puts [concat $a $b]
输出结果: hello world
```

2. lindex
```
set list1 {a b c d e f}
puts [lindex $list1 1]
```

3. llength
```
set list1 {a b c d e f}
puts [llength $list1]
```
question 如何得到一个列表的最后一个元素
```
set list2 {a b c d e f}
set b [epxr [lindex $list2] - 1]
puts [lindex $list2 $b]
```

4. laapend
语法格式: lappend 列表 新元素
warning: 并不是,lappend $列表 新元素
```
set a {1 2 3}
lappend a 4
pusts $a
输出结果: 1 2 3 4
```
```
set a {1 2 3}
set b {4 5}
lappend a $b
puts $a 
输出结果: 1 2 3 {4 5}
```
5. lsort
- 用法:lsort 开关 列表
- 功能:将列表按照一定规则排列,但不会改变原有列表的顺序,可以将新得到的赋值给另一个变量
- 开关:缺省时默认按照ASCII码进行排序。
       1. -real 按照浮点数值大小排序	
			 2. -unique 唯一化,删除重复元素
```
set list1 {b c a}
lsort $list1
puts $list1
输出结果: b c a  lsort并不会改变原有列表的顺序
set var [lsort $list1]
puts $var
输出结果: a b c 

set list2 {-2 3.1 5 0}
set var [lsort -real $list2]
puts $var
输出结果: -2 0 3.1 5 


set list3 {a c c b a d }
set var [lsort -unique $list3]
puts $var
输出结果:a b c d
```
## 数学运算指令 -expr
- 语法格式 expr 运算表达式
- 功能:将运算表达式求值

```
set a [expr 1 + 2]
puts $a
输出结果: 3

set b [expr 5/2]
puts $b
输出结果: 2

set c [expr 5.0/2]
puts $c
输出结果: 2.5
```

## 控制流
语法格式:
```
if {判断条件} j{
脚本语句
} elseif {判断条件}{
脚本语句
} else {
脚本语句
}
```
NOTE:##{##一定要写到上一行,因为如果不是这样，TCL解释器会认为在换行符中已结束,下一行会被当成新的命令,从而导致错误,##}##在哪里无所谓

```
set a 1
set b 2
if {$a > $b}{
puts $a
} else {
puts $b
}
```

1. 	`hello `



